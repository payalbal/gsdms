
GBIF-DATA_PROCESSING SQL QUERIES AND NOTES

-- Check size of table
SELECT pg_size_pretty(pg_relation_size('gbif.raw_data'));

-- Find rows with NULL values in table?


--FIRST FILTER
SELECT *
FROM gbif.raw_data
WHERE kingdom = 'Animalia'
AND decimallatitude IS NOT NULL
AND decimallongitude IS NOT NULL
AND year BETWEEN '1950' AND '2017' 
--ORDER BY gbifid
LIMIT 10 
--OFFSET 5;

-- Notes:
-- ORDER is a very slow process because ?it? it orders and queries each record to see if it is > or < than a previous entry...?? (Something like that) 
-- Alternative is to run first filter query on entire table and save as new table on boab (see code below)
-- Range can be specified using gbifid if required. For this get the min/max values for gbifid and specify chinks in succession. To get gbif min/max, the field might have to be CAST as an integer. 

--Task: Count records in gbif.raw_data
--SELECT reltuples::bigint AS estimate
--FROM   pg_class
--WHERE  oid = 'gbif.raw_data'::regclass;

-- Notes:
-- Info is obtained from the db metadata (pg-class) rather than the db itself 
-- Alternative COUNT(*) is a very slow process because ?it? Goes row-wise

------------------------------------------------------------
-- Task: Run first filter and create new db
------------------------------------------------------------

-- DROP TABLE gbif.first_filter

-- Create table by subsetting gbif.raw_data
CREATE TABLE gbif.first_filter AS
SELECT *
FROM gbif.raw_data
WHERE kingdom = 'Animalia'
AND decimallatitude IS NOT NULL
AND decimallongitude IS NOT NULL
AND year BETWEEN '1950' AND '2017' 
LIMIT 10;

-- Drop columns
ALTER TABLE gbif.first_filter
DROP COLUMN catalognumber,
DROP COLUMN collectioncode,
DROP COLUMN identifiedby,
DROP COLUMN institutioncode,
DROP COLUMN mediatype,
DROP COLUMN publishingorgkey,
DROP COLUMN recordedby,
DROP COLUMN rightsholder,
DROP COLUMN typestatus;

-- Set primary key
ALTER TABLE gbif.first_filter ADD PRIMARY KEY (gbifid);

-- Change gbifid to integer values
ALTER TABLE gbif.first_filter 
ALTER COLUMN gbifid TYPE INTEGER USING gbifid::integer;

-- Create new index: filter1_index
CREATE INDEX filter1_index
    ON gbif.first_filter USING btree
    (taxonkey COLLATE pg_catalog.default)
    TABLESPACE pg_default;

------------------------------------------------------------
-- Task: NOT COMPLETED: Combine queries into one:
------------------------------------------------------------

CREATE TABLE gbif.first_filter
(
    gbifid INTEGER PRIMARY KEY,
    datasetkey,
    occurrenceid,
    kingdom,
    phylum,
    raw_data.class,
    raw_data."order",
    raw_data.family,
    raw_data.genus,
    raw_data.species,
    raw_data.infraspecificepithet,
    raw_data.taxonrank,
    raw_data.scientificname,
    raw_data.countrycode,
    raw_data.locality,
    --raw_data.publishingorgkey,
    raw_data.decimallatitude,
    raw_data.decimallongitude,
    raw_data.coordinateuncertaintyinmeters,
    raw_data.coordinateprecision,
    raw_data.elevation,
    raw_data.elevationaccuracy,
    raw_data.depth,
    raw_data.depthaccuracy,
    raw_data.eventdate,
    raw_data.day,
    raw_data.month,
    raw_data.year,
    raw_data.taxonkey,
    raw_data.specieskey,
    raw_data.basisofrecord,
    --raw_data.institutioncode,
    --raw_data.collectioncode,
    --raw_data.catalognumber,
    raw_data.recordnumber,
    --raw_data.identifiedby,
    raw_data.license,
    --raw_data.rightsholder,
    --raw_data.recordedby,
    --raw_data.typestatus,
    raw_data.establishmentmeans,
    raw_data.lastinterpreted,
    --raw_data.mediatype,
    raw_data.issue,
--CONSTRAINT firstfilter_pkey PRIMARY KEY (gbifid)
)
AS SELECT *
FROM gbif.raw_data
WHERE kingdom = 'Animalia'
AND decimallatitude IS NOT NULL
AND decimallongitude IS NOT NULL
AND year BETWEEN '1950' AND '2017' 
--LIMIT 10;

-- Create new index: firstfilter_index
CREATE INDEX firstfilter_index
    ON gbif.firstfilter USING btree
    (taxonkey COLLATE pg_catalog."default")
    TABLESPACE pg_default;


-- Notes: 
-- Should I specify the primary key and if so where? Or perhaps I donâ€™t have to do it because you specified it for raw_data already? CONSTRAINT raw_data_pkey PRIMARY KEY (gbifid);
-- Casey: Yes this will need to be specified. This is run as a separate command to the CREATE TABLE. Alternately, you can CREATE TABLE as done for raw_data and 

-- Should I drop gbif_index before I create a new one for the new table? DROP INDEX gbif.gbif_index;
-- Casey: No you don't need to. Just create a new index for the new table

-- Should I run this through boab or on my local machine?
-- Casey: Yes because if you do so, you can shut down your local machine and it won't interrupt the process

-- Should I specify owner as is done when creating raw_data? 
-- Casey: No because you're already signed in and within the boab server


------------------------------------------------------------
-- Task: Change empty character vectors to NULL
------------------------------------------------------------

UPDATE gbif.temp1 
SET decimallongitude = NULL
WHERE decimallongitude::char = '';

-- Notes:
-- ALTER TABLE not suitable for this purpose because you can only change data type or do specific function that are inbuilt in ALTER TABLE. 
-- UPDATE (as well as ALTER COLUMN if that were used) can be specified for one column at a time because the WHERE clause is specific to that column

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
General Notes:
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

Ways to create a new table from existing table:
1. Subset an existing table (as done above)
2. Create new table structure based on an existing table and populate (as done for gbif.raw_data)
> 1. Creates the detailed SQL as in 2 anyway. 

Ways to change data type:
1. Specify data type for columns when creating new table.
CREATE TABLE gbif.first_filter
	gbifid INTEGER PRIMARY KEY,
	datasetkey [type] [column_constraint]...

3. Specify data type within another command/query using CAST. This will change the data for the computation but not in the table itself.
SELECT MAX(CAST(gbifid AS INTEGER)), MAX(CAST(gbifid AS INTEGER))
FROM gbif.raw_data 

4. Specify data type for column using ALTER TABLE within ALTER TABLE: This changes the table so it is good practice to run this within SELECT or CREATE VIEW before running it on the table. 




------------------------------------------------------------
SECOND FILTER
------------------------------------------------------------
-- Task: Change lat-long to numeric
------------------------------------------------------------

SELECT  decimallongitude
   FROM gbif.temp1
   WHERE decimallongitude IS NOT NULL;
   
   
   
DROP VIEW IF EXISTS gbif.temp;

CREATE OR REPLACE VIEW gbif.temp AS
SELECT 
CAST(decimallatitude AS NUMERIC)
FROM gbif.firstfilter
LIMIT 10;

CREATE TABLE gbif.temp1 AS
SELECT *
FROM gbif.firstfilter
LIMIT 1000;

ALTER TABLE gbif.temp1 
ALTER COLUMN decimallatitude TYPE NUMERIC USING decimallatitude::numeric;

-- Change lat-long to numeric values xx AT SECOND FILTER
ALTER TABLE gbif.first_filter 
ALTER COLUMN decimallatitude TYPE NUMERIC (13,10) USING decimallatitude::numeric
WHERE decimallatitude != "";
-- because of character non-values

--run query for "" to update to NULL and then CAST

> If table exists, drop it before CREATE TABLE



